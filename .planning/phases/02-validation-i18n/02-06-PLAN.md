---
phase: 02-validation-i18n
plan: 06
type: execute
wave: 2
depends_on:
  - "02-03"
files_modified:
  - docs/security/PENTEST_PLAN.md
  - docs/security/PENTEST_RESULTS.md
  - tests/security/test_security_audit.py
  - tests/security/test_authentication.py
  - tests/security/test_data_protection.py
  - tests/security/test_input_validation.py
autonomous: false
user_setup:
  - service: "Security Testing"
    why: "Comprehensive security validation"
    env_vars: []
    dashboard_config:
      - task: "Optional: Engage external penetration tester"
        location: "Security vendor of choice"

must_haves:
  truths:
    - "Authentication mechanisms tested for bypass"
    - "Data protection verified (DPAPI, bcrypt)"
    - "Input validation tested for injection attacks"
    - "No critical or high severity issues remain"
  artifacts:
    - path: "tests/security/test_authentication.py"
      provides: "Authentication security tests"
      min_lines: 80
    - path: "tests/security/test_data_protection.py"
      provides: "Data protection tests"
      min_lines: 60
    - path: "tests/security/test_input_validation.py"
      provides: "Input validation tests"
      min_lines: 80
    - path: "docs/security/PENTEST_RESULTS.md"
      provides: "Security test results documentation"
      min_lines: 100
  key_links:
    - from: "tests/security/test_authentication.py"
      to: "src/utils/password_hasher.py"
      via: "bcrypt verification"
      pattern: "PasswordHasher|verify_password"
    - from: "tests/security/test_data_protection.py"
      to: "src/utils/credential_manager.py"
      via: "DPAPI encryption test"
      pattern: "CredentialManager|encrypt|decrypt"
---

<objective>
Execute comprehensive security testing and document results.

Purpose: Verify the application has no critical or high severity security vulnerabilities, fulfilling requirement SEC-05. This validates the security controls implemented in Phase 0 and provides evidence for security-conscious deployments.

Output: Security test suite and penetration test results documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/GSD_ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-validation-i18n/02-RESEARCH.md
@.planning/phases/02-validation-i18n/02-03-PLAN.md
@src/utils/password_hasher.py
@src/utils/credential_manager.py
@src/config/validators.py
@SECURITY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create authentication security tests</name>
  <files>
    - tests/security/__init__.py
    - tests/security/conftest.py
    - tests/security/test_authentication.py
  </files>
  <action>
    1. Create tests/security/__init__.py:
       - Module docstring explaining security test suite
       - Constants for test parameters

    2. Create tests/security/conftest.py:
       - Import pytest, tempfile
       - @pytest.fixture for test_database (isolated SQLite)
       - @pytest.fixture for password_hasher instance
       - @pytest.fixture for credential_manager instance
       - Add pytest_configure for 'security' marker

    3. Create tests/security/test_authentication.py:
       - @pytest.mark.security
       - Import PasswordHasher, SettingsManager

       class TestPasswordHashing:
           - test_bcrypt_cost_factor_is_14():
             - Verify COST_FACTOR constant is 14
             - Hash password, verify time > 100ms (indicates proper cost)
           - test_timing_safe_comparison():
             - Compare correct vs incorrect passwords
             - Measure timing difference, assert < 10ms variance
           - test_hash_uniqueness():
             - Hash same password twice
             - Verify different hashes (salt working)
           - test_hash_format_bcrypt():
             - Verify hash starts with $2b$ (bcrypt identifier)

       class TestAccountLockout:
           - test_lockout_after_failed_attempts(test_database):
             - Configure lockout after 5 attempts
             - Attempt 5 wrong passwords
             - Verify 6th attempt rejected (locked out)
           - test_lockout_duration():
             - Trigger lockout
             - Verify unlocks after configured duration
           - test_successful_login_resets_counter():
             - 3 failed attempts, then success
             - Verify counter reset to 0

       class TestBruteForceProtection:
           - test_rate_limiting():
             - Attempt rapid authentication
             - Verify rate limiting kicks in
           - test_no_username_enumeration():
             - Attempt auth with non-existent user
             - Verify same error message as wrong password
  </action>
  <verify>
    - Run: pytest tests/security/test_authentication.py -v
    - All authentication tests pass
  </verify>
  <done>
    - bcrypt cost factor verified
    - Timing-safe comparison confirmed
    - Lockout mechanism tested
    - Rate limiting verified
  </done>
</task>

<task type="auto">
  <name>Task 2: Create data protection and input validation tests</name>
  <files>
    - tests/security/test_data_protection.py
    - tests/security/test_input_validation.py
  </files>
  <action>
    1. Create tests/security/test_data_protection.py:
       - @pytest.mark.security
       - Import CredentialManager

       class TestDPAPIEncryption:
           - test_credential_encryption():
             - Encrypt test credential
             - Verify ciphertext != plaintext
             - Decrypt and verify matches original
           - test_encryption_machine_bound():
             - Encrypt on this machine
             - Verify entropy file exists and is used
           - test_corrupted_ciphertext_fails():
             - Encrypt, corrupt 1 byte
             - Verify decryption raises error (not silent failure)
           - test_empty_string_handling():
             - Encrypt empty string
             - Verify decrypts to empty string

       class TestDatabaseFilePermissions:
           - test_database_file_not_world_readable():
             - Check file permissions on db file
             - Verify no "everyone" read access (Windows ACL)
           - test_entropy_file_protected():
             - Verify entropy file has restricted permissions

       class TestBackupEncryption:
           - test_backup_is_encrypted():
             - Create backup
             - Verify file is encrypted (not readable as plain JSON/SQLite)
           - test_backup_restore_requires_password():
             - Create encrypted backup
             - Verify restore fails without correct password

    2. Create tests/security/test_input_validation.py:
       - @pytest.mark.security
       - Import validators from src/config/validators

       class TestIPValidation:
           - test_valid_ipv4_accepted():
             - "192.168.1.100" accepted
           - test_invalid_ip_rejected():
             - "999.999.999.999" rejected
             - "not-an-ip" rejected
           - test_ip_with_port_rejected():
             - "192.168.1.100:4352" rejected (port separate)

       class TestPortValidation:
           - test_valid_port_accepted():
             - 4352, 1, 65535 accepted
           - test_invalid_port_rejected():
             - 0, 65536, -1 rejected
             - "abc" rejected

       class TestSQLInjectionPrevention:
           - test_parameterized_query():
             - Verify execute() uses ? placeholders
             - Attempt injection: "'; DROP TABLE--"
             - Verify no table dropped
           - test_no_string_format_in_sql():
             - Grep codebase for f".*SELECT\|INSERT\|UPDATE\|DELETE"
             - Verify 0 matches (no f-string SQL)

       class TestPathTraversal:
           - test_file_path_validation():
             - Attempt path traversal: "../../etc/passwd"
             - Verify rejected or sanitized
           - test_backup_path_restricted():
             - Verify backup only allowed in app data directory
  </action>
  <verify>
    - Run: pytest tests/security/test_data_protection.py tests/security/test_input_validation.py -v
    - All data protection and validation tests pass
  </verify>
  <done>
    - DPAPI encryption verified
    - File permissions checked
    - Input validation tested
    - SQL injection prevented
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Comprehensive security test suite covering:
    - Authentication (bcrypt, lockout, rate limiting)
    - Data protection (DPAPI, file permissions)
    - Input validation (IP, port, SQL injection)

    Also ran automated security scanning tools:
    - bandit (Python SAST)
    - safety (CVE checking)
    - pip-audit (dependency audit)
  </what-built>
  <how-to-verify>
    1. Run security test suite:
       ```bash
       pytest tests/security/ -v
       ```

    2. Run automated security scans:
       ```bash
       bandit -r src/ -ll
       safety check
       pip-audit
       ```

    3. Review results for:
       - Any test failures (must fix)
       - Any high/critical findings from bandit
       - Any CVEs from safety/pip-audit

    4. Optional: External penetration test
       - If budget allows, engage security firm
       - Scope: Network protocol, local privilege escalation
       - Timeline: 1-2 weeks typical

    5. Document findings and remediation in PENTEST_RESULTS.md
  </how-to-verify>
  <resume-signal>Type "approved" with security test results summary, or describe issues found</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Create penetration test documentation</name>
  <files>
    - docs/security/PENTEST_PLAN.md
    - docs/security/PENTEST_RESULTS.md
  </files>
  <action>
    1. Create docs/security/PENTEST_PLAN.md:
       # Penetration Test Plan

       ## Scope
       - Application: Projector Control v1.0
       - Components: Desktop GUI, network protocol, local storage
       - Exclusions: Physical projector hardware, network infrastructure

       ## Test Categories

       ### Authentication Testing
       - Password brute force
       - Timing attacks
       - Session management
       - Lockout bypass

       ### Data Protection Testing
       - Credential extraction from memory
       - Database file access
       - Entropy file tampering
       - Backup file analysis

       ### Network Protocol Testing
       - PJLink command injection
       - Man-in-the-middle (protocol limitation)
       - Denial of service

       ### Input Validation Testing
       - SQL injection
       - Command injection
       - Path traversal
       - Buffer overflow

       ## Methodology
       - OWASP Testing Guide v4.2
       - PTES (Penetration Testing Execution Standard)

       ## Tools
       - bandit (SAST)
       - safety (CVE)
       - Custom Python scripts
       - Wireshark (network capture)

    2. Create docs/security/PENTEST_RESULTS.md:
       # Penetration Test Results

       ## Executive Summary
       - Test Date: [current date]
       - Tester: Internal security testing
       - Overall Result: [PASS/CONDITIONAL PASS/FAIL]
       - Critical Issues: 0
       - High Issues: 0
       - Medium Issues: [count]
       - Low Issues: [count]

       ## Detailed Findings

       ### Authentication
       | Test | Result | Notes |
       |------|--------|-------|
       | Brute force protection | PASS | Lockout after 5 attempts |
       | Timing-safe comparison | PASS | <10ms variance |
       | bcrypt cost factor | PASS | Cost factor 14 |

       ### Data Protection
       | Test | Result | Notes |
       |------|--------|-------|
       | DPAPI encryption | PASS | Machine-bound |
       | File permissions | PASS | No world-read |
       | Backup encryption | PASS | AES-256-GCM |

       ### Input Validation
       | Test | Result | Notes |
       |------|--------|-------|
       | SQL injection | PASS | Parameterized queries |
       | Path traversal | PASS | Validated paths |
       | IP validation | PASS | RFC compliant |

       ### Network Protocol
       | Test | Result | Notes |
       |------|--------|-------|
       | PJLink auth | CONDITIONAL | MD5 (protocol limitation) |
       | Command injection | PASS | Input validated |

       ## Automated Scan Results

       ### bandit
       ```
       [paste bandit output]
       ```

       ### safety
       ```
       [paste safety output]
       ```

       ### pip-audit
       ```
       [paste pip-audit output]
       ```

       ## Remediation

       ### Required (Critical/High)
       - None identified

       ### Recommended (Medium/Low)
       - [list any medium/low findings]

       ## Conclusion
       The application meets security requirements with 0 critical/high issues.
       Known limitation: PJLink protocol uses MD5 authentication (cannot be changed).
  </action>
  <verify>
    - File exists: docs/security/PENTEST_PLAN.md
    - File exists: docs/security/PENTEST_RESULTS.md
    - Results show 0 critical/high issues (or document remediation)
  </verify>
  <done>
    - PENTEST_PLAN.md documents testing approach
    - PENTEST_RESULTS.md contains actual findings
    - 0 critical/high issues (SEC-05 requirement)
    - All findings documented with status
  </done>
</task>

</tasks>

<verification>
Run all security tests:
```bash
pytest tests/security/ -v
```

Run automated scans:
```bash
bandit -r src/ -ll
safety check
pip-audit
```

Check documentation:
```bash
cat docs/security/PENTEST_RESULTS.md | head -30
```
</verification>

<success_criteria>
- SEC-05: External penetration test completed with 0 critical/high issues
  - All security test categories pass
  - bandit shows no high/critical findings
  - safety shows no CVEs (or documented exceptions)
  - Results documented in PENTEST_RESULTS.md
- Security test suite covers:
  - Authentication mechanisms
  - Data protection (DPAPI, bcrypt)
  - Input validation
  - Network protocol
- Documentation complete for future audits
</success_criteria>

<output>
After completion, create `.planning/phases/02-validation-i18n/02-06-SUMMARY.md`
</output>
