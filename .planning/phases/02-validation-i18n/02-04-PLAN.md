---
phase: 02-validation-i18n
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src/database/sqlserver_manager.py
  - src/database/dialect.py
  - src/database/sqlserver_pool.py
  - src/config/settings.py
  - src/ui/dialogs/first_run_wizard.py
  - tests/integration/test_sqlserver_integration.py
autonomous: true
user_setup:
  - service: "SQL Server"
    why: "Testing SQL Server integration"
    env_vars:
      - name: TEST_SQLSERVER_CONNECTION
        source: "SQL Server instance connection string (LocalDB or Express)"
    dashboard_config:
      - task: "Install SQL Server Express LocalDB"
        location: "Visual Studio Installer or standalone download"

must_haves:
  truths:
    - "Application can connect to SQL Server database"
    - "SQL Server connection pooling manages multiple connections"
    - "First-run wizard can configure SQL Server connection"
    - "Data operations work identically in SQLite and SQL Server modes"
  artifacts:
    - path: "src/database/sqlserver_manager.py"
      provides: "SQL Server database operations"
      exports: ["SQLServerManager"]
      min_lines: 150
    - path: "src/database/sqlserver_pool.py"
      provides: "SQL Server connection pooling"
      exports: ["SQLServerConnectionPool"]
      min_lines: 80
    - path: "src/database/dialect.py"
      provides: "SQL dialect abstraction"
      exports: ["DatabaseDialect", "SQLiteDialect", "SQLServerDialect"]
      min_lines: 60
    - path: "tests/integration/test_sqlserver_integration.py"
      provides: "SQL Server integration tests"
      min_lines: 100
  key_links:
    - from: "src/database/sqlserver_manager.py"
      to: "pyodbc"
      via: "connection creation"
      pattern: "pyodbc\\.connect"
    - from: "src/database/sqlserver_pool.py"
      to: "src/database/sqlserver_manager.py"
      via: "pool provides connections"
      pattern: "get_connection|return_connection"
---

<objective>
Implement SQL Server database mode with connection pooling.

Purpose: Enable enterprise deployments with centralized SQL Server database, fulfilling requirements DB-04 (SQL Server mode) and DB-05 (connection pooling). This is critical for multi-workstation deployments.

Output: Working SQL Server integration with connection pooling, configurable via first-run wizard.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/GSD_ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-validation-i18n/02-RESEARCH.md
@src/database/connection.py
@src/config/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL dialect abstraction and SQL Server manager</name>
  <files>
    - src/database/dialect.py
    - src/database/sqlserver_manager.py
  </files>
  <action>
    1. Create src/database/dialect.py:
       ```python
       from abc import ABC, abstractmethod
       from typing import List, Tuple

       class DatabaseDialect(ABC):
           """Abstract base for database-specific SQL generation."""

           @abstractmethod
           def get_create_tables_sql(self) -> List[str]:
               """Return CREATE TABLE statements."""
               ...

           @abstractmethod
           def get_autoincrement_keyword(self) -> str:
               """Return auto-increment keyword (AUTOINCREMENT vs IDENTITY)."""
               ...

           @abstractmethod
           def get_boolean_type(self) -> str:
               """Return boolean type (INTEGER vs BIT)."""
               ...

           @abstractmethod
           def get_text_type(self, max_length: int = None) -> str:
               """Return text type (TEXT vs NVARCHAR)."""
               ...

           @abstractmethod
           def get_datetime_type(self) -> str:
               """Return datetime type (TEXT vs DATETIME2)."""
               ...

       class SQLiteDialect(DatabaseDialect):
           # Implement for SQLite (INTEGER, TEXT, etc.)
           ...

       class SQLServerDialect(DatabaseDialect):
           # Implement for SQL Server (IDENTITY, BIT, NVARCHAR, DATETIME2)
           ...
       ```

    2. Create src/database/sqlserver_manager.py:
       - Import pyodbc, logging, threading
       - Class SQLServerManager similar to DatabaseManager but for SQL Server
       - __init__(connection_string: str)
       - Use parameterized queries (? placeholders for pyodbc)
       - Implement same interface as DatabaseManager:
         - execute_query(), execute_many(), fetch_one(), fetch_all()
         - create_tables(), get_setting(), set_setting()
       - Handle SQL Server-specific error codes
       - Use SQLServerDialect for schema generation

    3. Key differences from SQLite:
       - Connection string format: "DRIVER={ODBC Driver 17 for SQL Server};SERVER=...;DATABASE=...;Trusted_Connection=yes"
       - Auto-commit behavior (SQL Server needs explicit commits)
       - Thread-local connections not needed (use pool instead)
       - Identity columns vs AUTOINCREMENT
  </action>
  <verify>
    - Run: python -c "from src.database.dialect import SQLiteDialect, SQLServerDialect; print('Dialects imported')"
    - Run: python -c "from src.database.sqlserver_manager import SQLServerManager; print('Manager imported')"
  </verify>
  <done>
    - DatabaseDialect abstraction with SQLite and SQL Server implementations
    - SQLServerManager class with full CRUD operations
    - Same interface as existing DatabaseManager
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SQL Server connection pooling</name>
  <files>
    - src/database/sqlserver_pool.py
    - src/database/sqlserver_manager.py (update to use pool)
  </files>
  <action>
    1. Create src/database/sqlserver_pool.py:
       ```python
       import logging
       import threading
       from queue import Queue, Empty, Full
       from typing import Optional
       import pyodbc

       logger = logging.getLogger(__name__)

       class SQLServerConnectionPool:
           """Thread-safe connection pool for SQL Server."""

           def __init__(
               self,
               connection_string: str,
               pool_size: int = 10,
               max_overflow: int = 5,
               timeout: float = 5.0
           ):
               self._connection_string = connection_string
               self._pool_size = pool_size
               self._max_overflow = max_overflow
               self._timeout = timeout
               self._pool: Queue = Queue(maxsize=pool_size)
               self._overflow_count = 0
               self._lock = threading.Lock()
               self._closed = False

               # Pre-create minimum connections
               self._initialize_pool()

           def _initialize_pool(self):
               """Pre-populate pool with connections."""
               for _ in range(min(3, self._pool_size)):
                   try:
                       conn = self._create_connection()
                       self._pool.put_nowait(conn)
                   except Exception as e:
                       logger.warning(f"Failed to pre-create connection: {e}")

           def _create_connection(self) -> pyodbc.Connection:
               """Create a new database connection."""
               return pyodbc.connect(self._connection_string, autocommit=False)

           def get_connection(self, timeout: float = None) -> pyodbc.Connection:
               """Get a connection from the pool."""
               if self._closed:
                   raise ConnectionPoolError("Pool is closed")

               timeout = timeout or self._timeout

               try:
                   # Try to get from pool
                   return self._pool.get(timeout=timeout)
               except Empty:
                   # Pool empty, try to create overflow connection
                   with self._lock:
                       if self._overflow_count < self._max_overflow:
                           self._overflow_count += 1
                           return self._create_connection()
                   raise PoolExhaustedError("Connection pool exhausted")

           def return_connection(self, conn: pyodbc.Connection) -> None:
               """Return a connection to the pool."""
               if self._closed:
                   conn.close()
                   return

               try:
                   # Rollback any uncommitted transactions
                   conn.rollback()
                   self._pool.put_nowait(conn)
               except Full:
                   # Pool full (overflow connection), close it
                   conn.close()
                   with self._lock:
                       self._overflow_count = max(0, self._overflow_count - 1)

           def close(self) -> None:
               """Close all connections in the pool."""
               self._closed = True
               while not self._pool.empty():
                   try:
                       conn = self._pool.get_nowait()
                       conn.close()
                   except Empty:
                       break

           @property
           def size(self) -> int:
               """Return current pool size."""
               return self._pool.qsize()

       class ConnectionPoolError(Exception):
           """Base exception for pool errors."""
           pass

       class PoolExhaustedError(ConnectionPoolError):
           """Pool has no available connections."""
           pass
       ```

    2. Update SQLServerManager to use pool:
       - Accept pool in constructor or create internally
       - Use context manager pattern for connections
       - Connection automatically returned on exception

    3. Add pool status methods for monitoring
  </action>
  <verify>
    - Run: python -c "from src.database.sqlserver_pool import SQLServerConnectionPool; print('Pool imported')"
    - Unit test: Create pool with mock connection string, verify get/return
  </verify>
  <done>
    - SQLServerConnectionPool manages 10+ connections
    - Overflow handling for burst load
    - Automatic connection return on errors
    - Pool status monitoring available
  </done>
</task>

<task type="auto">
  <name>Task 3: Update first-run wizard and create integration tests</name>
  <files>
    - src/ui/dialogs/first_run_wizard.py
    - src/config/settings.py
    - tests/integration/test_sqlserver_integration.py
  </files>
  <action>
    1. Update src/ui/dialogs/first_run_wizard.py:
       - DatabaseModePage already exists, enhance it:
         - Add "Test Connection" button for SQL Server mode
         - Show connection status (success/failure)
         - Validate connection string format
         - Store db_mode and connection_string in settings
       - Connection test should:
         - Create temporary SQLServerManager
         - Execute simple query (SELECT 1)
         - Show success message or error details

    2. Update src/config/settings.py:
       - Add settings keys: db_mode, sqlserver_connection_string
       - Add get_database_manager() factory method:
         - Returns DatabaseManager for SQLite mode
         - Returns SQLServerManager for SQL Server mode
       - Cache the manager instance

    3. Create tests/integration/test_sqlserver_integration.py:
       - Use LocalDB for CI testing (or skip if unavailable)
       - @pytest.mark.skipif(not has_localdb(), reason="LocalDB not available")

       Test cases:
       - test_sqlserver_connection_success(localdb_connection):
         - Connect to LocalDB, verify connection
       - test_sqlserver_crud_operations(localdb_connection):
         - Create, read, update, delete settings
       - test_sqlserver_pool_concurrent_access(localdb_connection):
         - 10 threads accessing pool simultaneously
       - test_sqlserver_pool_exhaustion_recovery():
         - Exhaust pool, wait for return, verify recovery
       - test_dialect_schema_generation():
         - SQLServerDialect generates valid SQL Server schema
       - test_settings_factory_sqlserver_mode():
         - Configure SQL Server mode, verify correct manager returned
  </action>
  <verify>
    - Run: pytest tests/integration/test_sqlserver_integration.py -v (may skip if no LocalDB)
    - Run: python -c "from src.config.settings import SettingsManager; print('Settings factory available')"
  </verify>
  <done>
    - First-run wizard can configure and test SQL Server connection
    - Settings factory returns correct manager based on mode
    - Integration tests cover CRUD and pool behavior
    - Tests skip gracefully if LocalDB unavailable
  </done>
</task>

</tasks>

<verification>
Test SQL Server components:
```bash
pytest tests/integration/test_sqlserver_integration.py -v
```

If LocalDB available:
```bash
python -c "
from src.database.sqlserver_manager import SQLServerManager
from src.database.sqlserver_pool import SQLServerConnectionPool

# Test with LocalDB
conn_str = 'DRIVER={ODBC Driver 17 for SQL Server};SERVER=(localdb)\\MSSQLLocalDB;DATABASE=master;Trusted_Connection=yes'
pool = SQLServerConnectionPool(conn_str, pool_size=5)
print(f'Pool created with {pool.size} connections')
pool.close()
"
```
</verification>

<success_criteria>
- DB-04: SQL Server mode fully integrated
  - SQLServerManager provides full CRUD operations
  - Same interface as DatabaseManager (drop-in replacement)
  - Schema generated via SQLServerDialect
- DB-05: SQL Server connection pooling operational
  - Pool manages 10+ connections
  - Overflow handling for burst load
  - Thread-safe get/return operations
- First-run wizard can configure SQL Server connection
- Integration tests pass (or skip gracefully)
</success_criteria>

<output>
After completion, create `.planning/phases/02-validation-i18n/02-04-SUMMARY.md`
</output>
